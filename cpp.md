# extern "C" 包含双重含义
1、被它修饰的目标是“extern”的
2、被它修饰的目标是“C”的
C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。


如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。

指向常量的指针变量——const int* p

指向变量的指针常量——int* const p

指向常量的指针常量——const int* const p

指针：
先找到*，然后看*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。


变量和对象不加extern永远是定义,类中的除外。 
函数只有函数头是声明，有函数体的是定义。 
类永远只是声明。类成员函数的函数体是定义。

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：

（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。

（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。

（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。

（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。

（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

# 从用户代码的角度，I/O操作的系统调用分为“阻塞”和“非阻塞”两种。

* “阻塞”的调用会在I/O调用完成前，挂起调用线程，即CPU会不再执行后续代码，而是等到I/O完成后再回来继续执行，在用户代码看来，线程停止执行了，在调用处等待了。

* “非阻塞”的调用则不同，I/O调用基本上是立即返回，而且往往实际上I/O此时并没有完成，所以需要用户的程序轮询结果。


空类的sizeof是1 ，当空类中有虚函数的时候 ，在32位机器上 大小是4，64位机器上是8【指向 虚表的指针，虚表是用来实现多态】

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

# Linux网络编程
TCP网络编程中常用的函数主要有：
* socket(),bind(),listen(),accept(),read(),write(),connect(),close();
* 服务器端的程序设计需要依次调用socket(),bind(),listen(),accept()，close()函数
* 客户端程序设计需要依次调用socket(),connect(),close()函数。

# 协议族和地址族之间的关系
| 协议族 | 地址族 | 描述 | 
| - | :-: | -: | 
| PF_UNIX | AF_UNIX | UNIX本地域协议族 | 
| PF_INET | AF_INET | TCP/TIPv4协议族 | 
| PF_INET6 | AF_INET6 | TCP/IPv6协议族 |

PF_* 与 AF_* 定义在socket.h 两者具有相同的值 

UNIX 和 LINUX中所有的东西都是文件。SOCKET 也是文件 ，它就是一个可读可写可控制的文件描述符

socket在创建的时候 默认是阻塞的，可以通过给socket系统调用的第二个参数传递SOCK_NONBLOCK标志，或者是通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞式的。阻塞和非阻塞可用于所以的文件描述符。
socket中基础的API中可能被阻塞的有：accept、send、recv、connect

# I/O 复用
IO复用一般是采用IO通知机制。它指的是，应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序。Linux上常用的IO复用函数select、poll和epoll_wait。IO复用函数本身是阻塞的，它们能够提高程序的效率的原因在于他们具有同时监听多个IO事件的能力。


# IO模型对比
| IO模型 | 读写操作和阻塞阶段 | 
| - | :-: | -: | 
| 阻塞IO | 程序阻塞与读写函数 | 
| IO复用 | 程序阻塞于IO复用系统调用 | 
| SIGIO信号 | 信号触发读写事件 用户程序执行读写操作 程序没有阻塞阶段 |
| 异步IO | 内核执行读写操作并触发读写完成事件 程序没有阻塞阶段 |

## IO阻塞和非阻塞是 文件 的属性
* 普通文件默认是非阻塞的
* 终端设备 /dev/tty 默认阻塞
* 管道 默认阻塞
* 套接字 默认阻塞


# fork创建进程
返回值 ==0 表示当前进程是子进程
返回值 >0 表示当前进程是父进程 
使用fork的时候 需要通过返回值判断进程是子进程还是父进程
fork出来的子进程在被fork出来的时候 数据和父进程是一样的【clone】 ，后续的操作父进程和子进程互不干扰 write on copy


### 孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

### 僵尸进程
    一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。


在使用pthread的创建线程的时候，本质上是创建了进程[创建的进程与父进程一样，包括pcb都是一样的，只有栈区不一样]。在创建子线程成功之后 ，父进程就退化为了主线程。对于linux操作系统来说 ，只有进程，没有线程一说。所谓的线程相关操作，是pthread库提供的操作行为，不是系统内核的行为。

在使用pthread_create创建子线程的时候，默认子线程和主线程是没有分离的，这种情况下 当子线程执行完毕后 没能力自己释放自己的pcb的，需要主线程为其释放pcb，使用pthread_jion[类比子进程wait理解].
在使用pthread_create创建线程之处，设置属性使得父子线程分离，也可以在创建之后 使用pthread_detech函数设置父子线程分离。设置了父子分离的子进程可以自己释放pcb

使用pthread_cancel杀死子线程的时候 ，子线程里面必须有 "取消点"
"取消点"
    1、系统调用的地方就是"取消点"
    2、使用pthread_testcancel设置"取消点"

exit()是用来退出进程的

# C++纯虚函数
* 关键字virtual
* 在成员函数的形参后面写上 "=0"
## 纯虚函数声明 固定写法 
virtual 函数类型 函数名 （参数表列） = 0；
### "=0" 并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”


linux中 7 中文件类型，其中4种伪文件

ldd 查看依赖的库
