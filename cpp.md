### 结构体变量内存对齐三原则
    1、变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小。
    2、结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节。
    3、结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节

### 拷贝构造函数
    如果没有实现拷贝构造函数，编译器会默认实现一个拷贝构造函数。

### 浅拷贝
    所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值操作，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了。

### 拷贝构造函数调用时机
    1、调用函数参数为对象
    2、函数返回值是对象
    3、对象赋值 B bb = b;

注意：用对象给一个引用赋值的时候，不会调用拷贝构造函数，比如：B bb& = b

拷贝有两种：深拷贝，浅拷贝。

    当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。

    深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。


# extern "C" 包含双重含义
1、被它修饰的目标是“extern”的
2、被它修饰的目标是“C”的
C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

### 虚函数 纯虚函数
虚函数可以有实现，纯虚函数不能有实现[由子类实现]
注意：多态必须通过虚函数实现, 使用的时候必须使用指针

如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。


指向常量的指针变量——const int* p

指向变量的指针常量——int* const p

指向常量的指针常量——const int* const p

指针识别：
先找到*，然后看*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。


变量和对象不加extern永远是定义,类中的除外。 
函数只有函数头是声明，有函数体的是定义。 
类永远只是声明。类成员函数的函数体是定义。

### std::ref std::cref std::bind
    函数编程的时，std::bind是直接对参数的拷贝，而不是引用。可以用std::ref解决

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：

（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。

（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。

（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。

（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。

（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

### 从用户代码的角度，I/O操作的系统调用分为“阻塞”和“非阻塞”两种。

* “阻塞”的调用会在I/O调用完成前，挂起调用线程，即CPU会不再执行后续代码，而是等到I/O完成后再回来继续执行，在用户代码看来，线程停止执行了，在调用处等待了。

* “非阻塞”的调用则不同，I/O调用基本上是立即返回，而且往往实际上I/O此时并没有完成，所以需要用户的程序轮询结果。

空类的sizeof是1 ，当空类中有虚函数的时候 ，在32位机器上 大小是4，64位机器上是8【指向 虚表的指针，虚表是用来实现多态】

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

## Linux网络编程
TCP网络编程中常用的函数主要有：
* socket(),bind(),listen(),accept(),read(),write(),connect(),close();
* 服务器端的程序设计需要依次调用socket(),bind(),listen(),accept()，close()函数
* 客户端程序设计需要依次调用socket(),connect(),close()函数。

# 协议族和地址族之间的关系
| 协议族 | 地址族 | 描述 | 
| - | :-: | -: | 
| PF_UNIX | AF_UNIX | UNIX本地域协议族 | 
| PF_INET | AF_INET | TCP/TIPv4协议族 | 
| PF_INET6 | AF_INET6 | TCP/IPv6协议族 |

PF_* 与 AF_* 定义在socket.h 两者具有相同的值 

UNIX 和 LINUX中所有的东西都是文件。SOCKET 也是文件 ，它就是一个可读可写可控制的文件描述符

socket在创建的时候 默认是阻塞的，可以通过给socket系统调用的第二个参数传递SOCK_NONBLOCK标志，或者是通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞式的。阻塞和非阻塞可用于所以的文件描述符。
socket中基础的API中可能被阻塞的有：accept、send、recv、connect

# I/O 复用
IO复用一般是采用IO通知机制。它指的是，应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序。Linux上常用的IO复用函数select、poll和epoll_wait。IO复用函数本身是阻塞的，它们能够提高程序的效率的原因在于他们具有同时监听多个IO事件的能力。


# IO模型对比
| IO模型 | 读写操作和阻塞阶段 | 
| - | :-: | -: | 
| 阻塞IO | 程序阻塞与读写函数 | 
| IO复用 | 程序阻塞于IO复用系统调用 | 
| SIGIO信号 | 信号触发读写事件 用户程序执行读写操作 程序没有阻塞阶段 |
| 异步IO | 内核执行读写操作并触发读写完成事件 程序没有阻塞阶段 |

## IO阻塞和非阻塞是 文件 的属性
* 普通文件默认是非阻塞的
* 终端设备 /dev/tty 默认阻塞
* 管道 默认阻塞
* 套接字 默认阻塞


# fork创建进程
返回值 ==0 表示当前进程是子进程
返回值 >0 表示当前进程是父进程 
使用fork的时候 需要通过返回值判断进程是子进程还是父进程
fork出来的子进程在被fork出来的时候 数据和父进程是一样的【clone】 ，后续的操作父进程和子进程互不干扰 write on copy


### 孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

### 僵尸进程
    一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。


在使用pthread的创建线程的时候，本质上是创建了进程[创建的进程与父进程一样，包括pcb都是一样的，只有栈区不一样]。在创建子线程成功之后 ，父进程就退化为了主线程。对于linux操作系统来说 ，只有进程，没有线程一说。所谓的线程相关操作，是pthread库提供的操作行为，不是系统内核的行为。

在使用pthread_create创建子线程的时候，默认子线程和主线程是没有分离的，这种情况下 当子线程执行完毕后 没能力自己释放自己的pcb的，需要主线程为其释放pcb，使用pthread_jion[类比子进程wait理解].
在使用pthread_create创建线程之处，设置属性使得父子线程分离，也可以在创建之后 使用pthread_detech函数设置父子线程分离。设置了父子分离的子进程可以自己释放pcb

使用pthread_cancel杀死子线程的时候 ，子线程里面必须有 "取消点"
"取消点"
    1、系统调用的地方就是"取消点"
    2、使用pthread_testcancel设置"取消点"

exit()是用来退出进程的

# C++纯虚函数
* 关键字virtual
* 在成员函数的形参后面写上 "=0"
## 纯虚函数声明 固定写法 
virtual 函数类型 函数名 （参数表列） = 0；
### "=0" 并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”

## 静态多态 动态多态
- 静态多态也叫早绑定 通过函数的重载实现
- 动态多态也叫做晚绑定 必须通过虚函数才能实现 

## 虚函数
* 纯虚函数不能有函数体
* 虚函数可以有函数体
```
    纯虚函数没有函数体；虚函数 有函数体
    含有纯虚函数的类都是抽象类
```

## 虚函数与重载函数的区别 
```
1、重载函数在类型和参数数量上一定不相同，而重定义的虚函数则要求参数的类型和个数、函数返回类型相同；
2、虚函数必须是类的成员函数，重载的函数则不一定是这样；
3、构造函数可以重载，但不能是虚函数，析构函数可以是虚函数
```

## virtual在函数中的使用限制
* 普通函数不能是虚函数，也就是说这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。
* 静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。
* 内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。
* 构造函数不能是虚函数，否则会出现编译错误。

类存在继承关系时，析构函数最好时虚函数。
用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，

# sizeof
* 传递数组首地址 则结果是数组的长度
* 传递指针 则结果是指针所占的字节宽度

linux中7种文件类型，其中4种伪文件
ldd 查看依赖的库

在#define中，标准只定义了#和##两种操作。#用来把参数转换成字符串，##则用来连接两个前后两个参数，把它们变成一个字符串。


要将数据存储在计算机中，必须指出存储的位置和所需要的内存空间。

C11表示原始字符串：R"自定义定界符 hello 自定义定界符"
第一种方式：R“hello world”
第二种方式：R“JSON hello world JSON” 采用自定义定界符


计算机在存储数据时必须跟踪的三种基本属性：
1、信息存储在何处[地址]
2、存储的值为多少[内容]
3、存储的信息是什么类型[类别]


变量静态存储的两种方式：整个程序声明周期都存在的变量
1、函数外定义变量[全局变量]
2、static修饰的变量

在C++中 当且仅当用于函数头或者函数原型中，int *arr 和int arr[]的含义才是相同的，即他们都是
一个指向int类型数据的指针。

extern告诉编译器 其声明的函数和变量可以供本文件或者其他文件使用. 

extern "C" 只是指定编译和链接的规约, 并不会影响语义, 所以在C++文件中该怎么写还得怎么写, 必须遵循C++的语法规范.
在C++源文件的语句前加上 extern "C" 的作用就是告诉编译器, 这一段代码按照类C的编译和链接规约来编译和链接(也就是按照类C的函数命名规范编译)

__cplusplus宏 只要是C++文件, 编译器就会自动定义这个宏
要想写一套C/C++均能调用的函数, 则必须按照C的方式编译 (因为C语言不支持C++, 而C++同时支持C/C++)
要实现C/C++混合编程其实很简单, 只需要在头文件加几行代码即可
    #ifdef __cplusplus
    extern "C" {

    /* content */

    #ifdef __cplusplus
    }
    #endif

指针类型分辨：
去掉指针变量前面的一个*，剩余的修饰符就是指针变量所存储的数据指向的类型[即指针指向的类型]。
eg：int **p，去掉一个*，变成int *p,那么p存贮的就是int类型的指针


函数指针：
    通常要声明指向特定类型的函数的指针，可以首先编写函数的原型，然后用"(*pf)"替换函数名称，那么pf就是指向这类函数的指针。

内联函数不能递归

引用变量用作函数形式参数，参数将使用原始的数据[不是使用的副本,类似传递指针]
引用必须在申明的时候必须进行初始化[函数形式参数除外]。
引用类似一个const指针
如果实参与引用类型不匹配，编译器会生成临时变量[仅当形参为const引用类型，临时变量只在函数调用期间存在，函数调用结束会被删除不再占用内存]
如果引用参数是const，编译器将在如下两种情况生成临时变量：
1、实参的类型正确 但不是左值
2、实参的类型不正确，但是可以转换为正确的类型。

头文件中常包含的内容：
1、函数声明
2、使用#define 或者const定义的符号常量
3、结构声明
4、类声明
5、模版声明
6、内联函数


数据存储
自动存储持续性：
    在函数定义中声明的变量的存储持续性为自动的，它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。
静态存储持续性：
    在函数定义之外定义的变量和使用关键字static定义的变量的存储持续性都为静态，它们在程序整个运行过程中都存在。
线程存储持续性[C11]:
    如果变量使用关键字thread_local声明的，其生命周期与所属的线程一样。
动态存储持续性：
    用new运算符分配的内存一直都存在，直到使用delete运算符将其释放或程序结束为止，这种内存的存储持续性为动态，也被称为自由存储或堆。

链接性描述了名称在不同单元间共享，链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中函数共享。
自动变量的名称没有链接性，因为它们不能共享。

C++函数的作用域可以是整个类或者整个名称空间(包括全局的)

C++两种变量的声明：
1、定义声明[定义]，它给变量分配存储空间
2、引用声明[声明]，不给变量分配存储空间，只是引用已有的变量。引用声明使用关键字extern，且不进行初始化[否则声明就成为了定义，导致内存的分配]。

static修饰的全局变量只能在本文件中使用，其他文件不可用。如果由同名的全局变量，那么该static修饰的全局变量将隐藏外部的同名的全局变量。如果一个全局变量只希望在本文件中使用，那么可以使用static修饰。
const修饰的全局变量使用范围与static全局变量一样。可以使用extern改变其范围
eg: extern const int states = 100;在使用该变量的文件中使用extern来声明它。

函数的默认作用域是全局的，可以使用static限制其为本文件

C++查找函数：
    如果该函数是static，那么编译器将会在定义该函数的文件中查找，否则编译器将会在所有的程序文件中查找，如果在程序文件中没有找到，编译器将会在库中查找。

通常情况下编译器使用三块内存：
1、存储静态变量
2、自动变量
3、动态存储

不能在未命名的名称空间所属的文件之外使用该名称空间中的名称。

在类的声明文件中定义的方法会自动成为内联函数

内联函数的特殊规则要求在每个使用它的文件中都要对其进行定义，为了确保内联定义对多文件程序中的所有文件都
可用的、最简便的方法是：将内联定义放在定义类的头文件中。

构造函数：
    如果不提供任何构造函数，编译器会自动生成一个默认的构造函数。
定义默认构造函数：
1、给已有的构造函数提供默认值
2、定义一个没有参数的构造函数

析构函数：
    对象的生命周期结束的时或者调用free、delete，程序会自动的调用对象的析构函数，可以做资源释放的处理。

定义类对象数组：
    编译器首先会使用默认的构造函数来创建数组元素，然后创建临时的对象
    随后将临时对象的内容复制到相应的元素中,因此要创建类对象数组，那么这个类必须由默认的构造函数。

重载运算符：可以通过成员函数和非成员函数实现
1、重载后的运算符必须至少有一个操作数是用户类型
2、使用运算符时不能违运算符原来的句法规则，也不能修改运算法的优先级，比如：不能将求模运算符%重载成使用一个操作数
3、不能创建新的运算符
4、不能重载一下运算符
    sizeof：sizeof运算符
    “.”: 成员运算符
    “.*”: 成员指针运算符
    “::”: 作用域解析运算符
    “?:”: 条件运算符
    “typeid”: RTTI运算符
    "const_cast": 强制类型转化运算符
    "dynamic_cast": 强制类型转化运算符
    "reinterpret_cast": 强制类型转化运算符
    "static_cast": 强制类型转化运算符
5、一下运算符只能通过成员函数进行重载
    “=”：赋值运算符
    “()”：函数调用运算符
    “[]”：下标运算符
    “->”：通过指针访问类成员的运算符

重载二元运算符时，参数会按照从左到右分在运算符两边

友元：
1、友元函数,只有类声明可以决定哪一个函数是友元
    使用友元函数注意的要点：
    a、类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。
    b、一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。
    c、友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。
    d、友元函数在调用上同一般函数一样，不必通过对对象进行引用。

2、友元类
3、友元成员函数

构造函数可以用作自动类型转换函数，但是这会导致一些意外的问题，可以使用关键字explicit关闭这种特性。但是关键字explicit不能禁止显示类型转化。

类创建类型转换函数：
1、转换函数必须是类方法
2、转换函数不能指定返回类型
3、转换函数不能有参数

C++为类提供的类型转换：
1、只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。
2、被称为转换函数的特殊成员运算符函数，用于将类对象转换为其他的类型。

类的声明中不能初始化static成员，这是因为声明描述了如何分配内存，但是并不会分配内存。
对于类的静态成员，可以在类声明之外使用单独的语句来进行初始化。但是如果静态成员时整型或者枚举const，则可以在类声明中初始化。

删除对象只能回收对象本身所占据的内存，但是没办法回收类成员指针指向的内存[成员指向的内存 需要用户主动处理]

内存：
new <-----> delete
new[] <-----> delete[]

拷贝构造函数：
    当用一个对象去初始化另外一个对象的时候 编译器会调用拷贝构造函数。
    当程序按值传递对象或者函数返回对象时，都将使用拷贝构造函数。按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。

    默认的拷贝构造函数只会是浅复制对象成员的值。


C++自动提供的成员函数:
1、默认构造函数，如果没有定义构造函数
2、默认析构函数，如果没有定义析构函数
3、拷贝构造函数，如果没有定义
4、赋值运算符，如果没有重载赋值运算符
5、地址运算符，如果没有重载赋值运算符

成员初始化列表：只能在构造函数中使用这种语法。
下面四种情况必须使用成员初始化列表
1、当初始化一个 reference member时;
2、当初始化一个 const member时;
3、当调用一个 base class 的 constructor, 而他拥有一组参数时;
4、当调用一个 member class 的 constructor, 而他拥有一组参数时;

使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但是必须通过基类的公有和保护方法访问。

构造顺序：
    父类 --> 子类
析构顺序：
    子类 --> 父类

基类指针可以指向子类对象，基类引用可以引用子类对象

多态：能够表现出多态的方法必须是 virtual的
通过指针或者引用调用virtual方法，将根据实际的类型的来调用方法。如果是通过对象调用virtual方法，将根据指针或者引用的类型调用实际的方法。

方法在基类中声明为virtual的，在其继承类中自动为virtual方法。

虚析构函数：
    当析构函数是虚函数时，当父类指针指向子类对象时，delete(父类指针)时会导致父类的析构函数自动被调用。否则，如果父类的析构函数不是虚函数，那么只会调用父类的析构函数。

 子类重写父类方法时，会屏蔽掉父类的方法.

 C++ 允许在类实现纯虚函数，但是该类仍然是抽象类。子类在继承父类的时候，对纯虚函数的声明不需要在声明为纯虚函数了。

异常处理是C++相对较新的特性，有些老版本的编译器有可能不支持，有些编译器默认关闭异常处理特性。

abort()函数终止程序的执行，同时向标准错误流发送错误信息，该函数是否刷行缓冲区，取决与具体的实现。
exit()函数终止程序，同时会刷新缓冲区，但是不会发送错误消息。

catch异常为什么采用引用？
    catch本质是捕获throw抛出异常的拷贝，但是采用引用声明可以匹配派生类的异常[基类引用可以执行派生类对象]

C++标准提供了一种在失败时返回空指针的new
int *pi = new (std::nothrow) int;

RTTI[运行时类型识别]只能用于含有虚函数的类。
RTTI：
1、dynamic_cast,可以处理是否可以安全的将一个指针转换为特定类型的指针。如果能安全的转换，返回指针指，否则返回 空指针。dynamic_cast用于引用转换时，失败会导致bad_cast的异常。
2、typeid，确定两个对象是否为相同的类型. typeid(A) == typeid(B)是否为相同的类型.
3、type_info

类型转换：
1、dynamic_cast
2、const_cast 可以用于删除变量的const属性，但是删除后不一定能修改变量。
3、static_cast
4、reinterpret_cast

智能指针本质上是对“指针”做了一层封装的类对象
自动释放的原理：
    当智能指针生命周期结束[栈生命周期结束或者是引用计数为0]，在其析构函数函数中，对其封装的指针做释放内存的操作。

STL迭代器是个广义的指针。


创建别名：
 typedef、using[c++11新语法]
 eg: typedef int myint
    using myint = int

将右值关联到右值应用会导致该右值存储在特殊的为止，并且可以通过右值引用访问该数据。

通常会使用移动语意实现资源的转移而非拷贝[用户自定义实现移动拷贝构造函数和移动赋值运算符]，转移之后资源的所有权将易主，这样避免了资源不必要的拷贝[移动主要发生在临时对象复制到新对象的时候就不需要copy,而是直接数据移动。所以主要是右值对象发生move]。

特殊成员函数：
    C++11在原有的4个特殊成员函数[默认构造函数、复制构造函数、赋值运算符、析构函数]的基础上增加了移动构造函数和移动赋值运算符。
    例外情况：如果提供了析构函数、拷贝构造函数或者赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符；如果提供了移动构造函数或者移动赋值运算符，编译器就昂不会自动提供拷贝构造函数和赋值运算符。
    默认的移动构造函数和移动赋值运算符的工作方式以拷贝版本一致[浅拷贝]

std::move实现将左值强转为右值。

临时对象[比如函数调用返回一个对象]的触发的移动拷贝构造函数，编译器会直接将临时对象的所有权转移[不会触发移动拷贝构造函数，但是如果把移动拷贝构造函数声明为delete的 就是错误的]：
    Class_A a = std::move(temp_class_a)将一个左值强转为右值再赋值，会触发移动赋值运算符
    Class_A a(temp_class_a) 会触发移动拷贝构造函数

C++ Lambda表达式
Lambda 的语法形式如下：
[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}
Lambda 主要分为五个部分：[函数对象参数]、(操作符重载函数参数)、mutable 或 exception 声明、-> 返回值类型、{函数体}.

关于bind的用法：
可将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
调用bind的一般形式：auto newCallable = bind(callable,arg_list);
其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable,并传给它arg_list中的参数。
arg_list中的参数可能包含形如_n的名字，其中n是一个整数，这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，以此类推。

前缀“L”可以指示宽字符常量和宽字符串，eg:L"中国"
前缀u和U分别指出字符字面值的类型为char16_t和char32_t。
至于L还是u前缀的问题..属于厂商自定义.这个标准没有确定死的.毕竟这只是厂商实现的辅助字符转换的功能,而不是特定语法.

信号：
man signal 查看信号
kill -l 查看系统的所有信息

线程同步一般用到的方法：
1、互斥量
2、条件变量
3、信号量
c++11 中互斥锁和条件变量是配合使用的，互斥锁用于短期锁定，主要保证线程对临界区的进入；条件变量用于线程长期等待，在wait的时候会释放锁。

在使用std::thread的时候，对创建的线程有两种操作：等待/分离，也就是join/detach操作。join()操作是在std::thread t(func)后“某个”合适的地方调用，其作用是回收对应创建的线程的资源，避免造成资源的泄露。detach()操作是在std::thread t(func)后马上调用，用于把被创建的线程与做创建动作的线程分离，分离的线程变为后台线程,其后，创建的线程的“死活”就与其做创建动作的线程无关，它的资源会被init进程回收。

在CPP文件中引用C的函数：
extern “C”{
    #include<test.h>
}

C++模板是什么，底层怎么实现的？
1)	编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
2)	这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。




















