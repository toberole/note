### 结构体变量内存对齐三原则
    1、变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小。
    2、结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节。
    3、结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节

### 拷贝构造函数
    如果没有实现拷贝构造函数，编译器会默认实现一个拷贝构造函数。

### 浅拷贝
    所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值操作，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了。

### 拷贝构造函数调用时机
    1、调用函数参数为对象
    2、函数返回值是对象
    3、对象赋值 B bb = b;

注意：用对象给一个引用赋值的时候，不会调用拷贝构造函数，比如：B bb& = b

拷贝有两种：深拷贝，浅拷贝。

    当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。

    深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。


# extern "C" 包含双重含义
1、被它修饰的目标是“extern”的
2、被它修饰的目标是“C”的
C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

### 虚函数 纯虚函数
虚函数可以有实现，纯虚函数不能有实现[由子类实现]
注意：多态必须通过虚函数实现, 使用的时候必须使用指针

如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。


指向常量的指针变量——const int* p

指向变量的指针常量——int* const p

指向常量的指针常量——const int* const p

指针识别：
先找到*，然后看*的两边，右边是对指针p本身的限定，左边是对p所指向的东西的限定。


变量和对象不加extern永远是定义,类中的除外。 
函数只有函数头是声明，有函数体的是定义。 
类永远只是声明。类成员函数的函数体是定义。

### std::ref std::cref std::bind
    函数编程的时，std::bind是直接对参数的拷贝，而不是引用。可以用std::ref解决

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：

（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。

（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。

（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。

（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。

（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

### 从用户代码的角度，I/O操作的系统调用分为“阻塞”和“非阻塞”两种。

* “阻塞”的调用会在I/O调用完成前，挂起调用线程，即CPU会不再执行后续代码，而是等到I/O完成后再回来继续执行，在用户代码看来，线程停止执行了，在调用处等待了。

* “非阻塞”的调用则不同，I/O调用基本上是立即返回，而且往往实际上I/O此时并没有完成，所以需要用户的程序轮询结果。


空类的sizeof是1 ，当空类中有虚函数的时候 ，在32位机器上 大小是4，64位机器上是8【指向 虚表的指针，虚表是用来实现多态】

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

## Linux网络编程
TCP网络编程中常用的函数主要有：
* socket(),bind(),listen(),accept(),read(),write(),connect(),close();
* 服务器端的程序设计需要依次调用socket(),bind(),listen(),accept()，close()函数
* 客户端程序设计需要依次调用socket(),connect(),close()函数。

# 协议族和地址族之间的关系
| 协议族 | 地址族 | 描述 | 
| - | :-: | -: | 
| PF_UNIX | AF_UNIX | UNIX本地域协议族 | 
| PF_INET | AF_INET | TCP/TIPv4协议族 | 
| PF_INET6 | AF_INET6 | TCP/IPv6协议族 |

PF_* 与 AF_* 定义在socket.h 两者具有相同的值 

UNIX 和 LINUX中所有的东西都是文件。SOCKET 也是文件 ，它就是一个可读可写可控制的文件描述符

socket在创建的时候 默认是阻塞的，可以通过给socket系统调用的第二个参数传递SOCK_NONBLOCK标志，或者是通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞式的。阻塞和非阻塞可用于所以的文件描述符。
socket中基础的API中可能被阻塞的有：accept、send、recv、connect

# I/O 复用
IO复用一般是采用IO通知机制。它指的是，应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序。Linux上常用的IO复用函数select、poll和epoll_wait。IO复用函数本身是阻塞的，它们能够提高程序的效率的原因在于他们具有同时监听多个IO事件的能力。


# IO模型对比
| IO模型 | 读写操作和阻塞阶段 | 
| - | :-: | -: | 
| 阻塞IO | 程序阻塞与读写函数 | 
| IO复用 | 程序阻塞于IO复用系统调用 | 
| SIGIO信号 | 信号触发读写事件 用户程序执行读写操作 程序没有阻塞阶段 |
| 异步IO | 内核执行读写操作并触发读写完成事件 程序没有阻塞阶段 |

## IO阻塞和非阻塞是 文件 的属性
* 普通文件默认是非阻塞的
* 终端设备 /dev/tty 默认阻塞
* 管道 默认阻塞
* 套接字 默认阻塞


# fork创建进程
返回值 ==0 表示当前进程是子进程
返回值 >0 表示当前进程是父进程 
使用fork的时候 需要通过返回值判断进程是子进程还是父进程
fork出来的子进程在被fork出来的时候 数据和父进程是一样的【clone】 ，后续的操作父进程和子进程互不干扰 write on copy


### 孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

### 僵尸进程
    一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。


在使用pthread的创建线程的时候，本质上是创建了进程[创建的进程与父进程一样，包括pcb都是一样的，只有栈区不一样]。在创建子线程成功之后 ，父进程就退化为了主线程。对于linux操作系统来说 ，只有进程，没有线程一说。所谓的线程相关操作，是pthread库提供的操作行为，不是系统内核的行为。

在使用pthread_create创建子线程的时候，默认子线程和主线程是没有分离的，这种情况下 当子线程执行完毕后 没能力自己释放自己的pcb的，需要主线程为其释放pcb，使用pthread_jion[类比子进程wait理解].
在使用pthread_create创建线程之处，设置属性使得父子线程分离，也可以在创建之后 使用pthread_detech函数设置父子线程分离。设置了父子分离的子进程可以自己释放pcb

使用pthread_cancel杀死子线程的时候 ，子线程里面必须有 "取消点"
"取消点"
    1、系统调用的地方就是"取消点"
    2、使用pthread_testcancel设置"取消点"

exit()是用来退出进程的

# C++纯虚函数
* 关键字virtual
* 在成员函数的形参后面写上 "=0"
## 纯虚函数声明 固定写法 
virtual 函数类型 函数名 （参数表列） = 0；
### "=0" 并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是虚函数”

## 静态多态 动态多态
- 静态多态也叫早绑定 通过函数的重载实现
- 动态多态也叫做晚绑定 必须通过虚函数才能实现 

## 虚函数
* 纯虚函数不能有函数体
* 虚函数可以有函数体
```
    纯虚函数没有函数体；虚函数 有函数体
    含有纯虚函数的类都是抽象类
```

## 虚函数与重载函数的区别 
```
1、重载函数在类型和参数数量上一定不相同，而重定义的虚函数则要求参数的类型和个数、函数返回类型相同；
2、虚函数必须是类的成员函数，重载的函数则不一定是这样；
3、构造函数可以重载，但不能是虚函数，析构函数可以是虚函数
```

## virtual在函数中的使用限制
* 普通函数不能是虚函数，也就是说这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。
* 静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。
* 内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。
* 构造函数不能是虚函数，否则会出现编译错误。

# sizeof
* 传递数组首地址 则结果是数组的长度
* 传递指针 则结果是指针所占的字节宽度

linux中7种文件类型，其中4种伪文件
ldd 查看依赖的库

在#define中，标准只定义了#和##两种操作。#用来把参数转换成字符串，##则用来连接两个前后两个参数，把它们变成一个字符串。


要将数据存储在计算机中，必须指出存储的位置和所需要的内存空间。







