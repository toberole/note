synrhronized用于同步

对象作为锁还有个名字叫做对象监视器或者内部锁。获取内部锁的唯一方式就是进入内部锁保护的同步代码块或者是同步方法。内部锁是一种互斥锁。

内部锁是一种可重入的锁，即一个线程试图获取其已经占有的锁的时，可以成功的获取到锁。可重入是通过为每一个锁对象关联一个请求计数和一个占有它的线程，每次占有锁的线程推出同步代码的时候，该锁的请求计数都会减一，直到请求计数为0表示该锁没有被线程占有，锁被释放。

当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：
Contention List：所有请求锁的线程将被首先放置到该竞争队列
Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List
Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set
OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck
Owner：获得锁的线程称为Owner
!Owner：释放锁的线程

为了节省内存，对于下列包装对象的两个实例，当它们的基本值相同时，他们总是==：  
 Boolean、Byte、Character[\u0000 - \u007f(7f是十进制的127)]、Integer[-128 — 127]  





















